<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AUM Real-Time Voice Client</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .status {
            text-align: center;
            padding: 15px;
            margin: 20px 0;
            border-radius: 10px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .status.disconnected { background: rgba(220, 53, 69, 0.3); }
        .status.connected { background: rgba(40, 167, 69, 0.3); }
        .status.listening { background: rgba(255, 193, 7, 0.3); }
        .status.speaking { background: rgba(23, 162, 184, 0.3); }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        button {
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 150px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .connect-btn {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
        }
        
        .disconnect-btn {
            background: linear-gradient(45deg, #dc3545, #fd7e14);
            color: white;
        }
        
        .voice-btn {
            background: linear-gradient(45deg, #007bff, #6610f2);
            color: white;
            font-size: 18px;
            min-width: 200px;
        }
        
        .voice-btn.active {
            background: linear-gradient(45deg, #dc3545, #e83e8c);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .conversation {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .message {
            margin: 10px 0;
            padding: 10px 15px;
            border-radius: 10px;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .user-message {
            background: rgba(0, 123, 255, 0.3);
            margin-left: 20px;
        }
        
        .agent-message {
            background: rgba(40, 167, 69, 0.3);
            margin-right: 20px;
        }
        
        .partial-message {
            background: rgba(255, 193, 7, 0.2);
            font-style: italic;
            opacity: 0.8;
        }
        
        .vad-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
        }
        
        .vad-light {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }
        
        .vad-light.active {
            background: #28a745;
            box-shadow: 0 0 20px #28a745;
        }
        
        .latency-info {
            text-align: center;
            font-size: 14px;
            opacity: 0.8;
            margin: 10px 0;
        }
        
        .audio-visualizer {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2px;
            height: 50px;
            margin: 20px 0;
        }
        
        .bar {
            width: 4px;
            height: 10px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            transition: height 0.1s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéôÔ∏è AUM Real-Time Voice Assistant</h1>
        
        <div id="status" class="status disconnected">
            Disconnected - Click Connect to start
        </div>
        
        <div class="controls">
            <button id="connectBtn" class="connect-btn">Connect</button>
            <button id="disconnectBtn" class="disconnect-btn" style="display: none;">Disconnect</button>
        </div>
        
        <div class="controls">
            <button id="voiceBtn" class="voice-btn" disabled>üé§ Start Voice Chat</button>
        </div>
        
        <div class="vad-indicator">
            <span>Voice Activity:</span>
            <div id="vadLight" class="vad-light"></div>
            <span id="vadStatus">Inactive</span>
        </div>
        
        <div class="audio-visualizer" id="visualizer">
            <!-- Audio bars will be generated here -->
        </div>
        
        <div class="latency-info" id="latencyInfo">
            Latency: -- ms
        </div>
        
        <div class="conversation" id="conversation">
            <div class="message agent-message">
                Welcome! I'm Alex from Auburn University at Montgomery. Click "Start Voice Chat" to begin our conversation.
            </div>
        </div>
    </div>

    <script>
        class RealtimeVoiceClient {
            constructor() {
                this.ws = null;
                this.audioContext = null;
                this.mediaStream = null;
                this.processor = null;
                this.isRecording = false;
                this.isConnected = false;
                this.sttActive = false;
                this.lastSpeechTime = 0;
                this.currentAudioSource = null; // Track current playing audio for interruption
                
                this.initializeElements();
                this.setupEventListeners();
                this.createAudioVisualizer();
            }
            
            initializeElements() {
                this.statusEl = document.getElementById('status');
                this.connectBtn = document.getElementById('connectBtn');
                this.disconnectBtn = document.getElementById('disconnectBtn');
                this.voiceBtn = document.getElementById('voiceBtn');
                this.conversationEl = document.getElementById('conversation');
                this.vadLight = document.getElementById('vadLight');
                this.vadStatus = document.getElementById('vadStatus');
                this.latencyInfo = document.getElementById('latencyInfo');
                this.visualizer = document.getElementById('visualizer');
            }
            
            setupEventListeners() {
                this.connectBtn.addEventListener('click', () => this.connect());
                this.disconnectBtn.addEventListener('click', () => this.disconnect());
                this.voiceBtn.addEventListener('click', () => this.toggleVoiceChat());
            }
            
            createAudioVisualizer() {
                for (let i = 0; i < 32; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'bar';
                    this.visualizer.appendChild(bar);
                }
            }
            
            updateStatus(message, className) {
                this.statusEl.textContent = message;
                this.statusEl.className = `status ${className}`;
            }
            
            async connect() {
                try {
                    this.updateStatus('Connecting...', 'connecting');
                    
                    this.ws = new WebSocket('ws://localhost:8766');
                    
                    this.ws.onopen = () => {
                        this.isConnected = true;
                        this.updateStatus('Connected - Ready for voice chat', 'connected');
                        this.connectBtn.style.display = 'none';
                        this.disconnectBtn.style.display = 'inline-block';
                        this.voiceBtn.disabled = false;
                    };
                    
                    this.ws.onmessage = (event) => this.handleMessage(JSON.parse(event.data));
                    
                    this.ws.onclose = () => {
                        this.isConnected = false;
                        this.updateStatus('Disconnected', 'disconnected');
                        this.connectBtn.style.display = 'inline-block';
                        this.disconnectBtn.style.display = 'none';
                        this.voiceBtn.disabled = true;
                        this.stopVoiceChat();
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateStatus('Connection error', 'disconnected');
                    };
                    
                } catch (error) {
                    console.error('Connection failed:', error);
                    this.updateStatus('Connection failed', 'disconnected');
                }
            }
            
            disconnect() {
                if (this.ws) {
                    this.ws.close();
                }
                this.stopVoiceChat();
            }
            
            async toggleVoiceChat() {
                if (!this.isRecording) {
                    await this.startVoiceChat();
                } else {
                    this.stopVoiceChat();
                }
            }
            
            async startVoiceChat() {
                try {
                    // Request microphone access
                    this.mediaStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    
                    // Create audio context
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000
                    });
                    
                    const source = this.audioContext.createMediaStreamSource(this.mediaStream);
                    
                    // Create processor for real-time audio processing (smaller buffer -> lower latency)
                    this.processor = this.audioContext.createScriptProcessor(1024, 1, 1);
                    
                    this.processor.onaudioprocess = (event) => {
                        if (this.sttActive) {
                            const inputData = event.inputBuffer.getChannelData(0);
                            this.sendAudioChunk(inputData);
                            this.updateAudioVisualizer(inputData);
                        }
                    };
                    
                    source.connect(this.processor);
                    this.processor.connect(this.audioContext.destination);
                    
                    // Start STT streaming
                    this.ws.send(JSON.stringify({
                        type: 'stt_stream_start',
                        language: 'en-US'
                    }));
                    
                    this.isRecording = true;
                    this.voiceBtn.textContent = 'üõë Stop Voice Chat';
                    this.voiceBtn.classList.add('active');
                    this.updateStatus('Listening... Speak naturally!', 'listening');
                    
                } catch (error) {
                    console.error('Failed to start voice chat:', error);
                    alert('Failed to access microphone. Please check permissions.');
                }
            }
            
            stopVoiceChat() {
                // Stop any playing audio first
                this.stopCurrentAudio();
                
                if (this.processor) {
                    this.processor.disconnect();
                    this.processor = null;
                }
                
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
                
                if (this.mediaStream) {
                    this.mediaStream.getTracks().forEach(track => track.stop());
                    this.mediaStream = null;
                }
                
                if (this.ws && this.sttActive) {
                    this.ws.send(JSON.stringify({ type: 'stt_stream_end' }));
                }
                
                this.isRecording = false;
                this.sttActive = false;
                this.voiceBtn.textContent = 'üé§ Start Voice Chat';
                this.voiceBtn.classList.remove('active');
                this.updateVAD(false);
                
                if (this.isConnected) {
                    this.updateStatus('Connected - Click Start Voice Chat', 'connected');
                }
            }
            
            sendAudioChunk(audioData) {
                // Convert Float32Array to PCM16
                const pcm16 = new Int16Array(audioData.length);
                for (let i = 0; i < audioData.length; i++) {
                    pcm16[i] = Math.max(-32768, Math.min(32767, audioData[i] * 32768));
                }
                
                // Convert to base64
                const audioBase64 = btoa(String.fromCharCode(...new Uint8Array(pcm16.buffer)));
                
                this.ws.send(JSON.stringify({
                    type: 'stt_audio_chunk',
                    audio: audioBase64
                }));
            }
            
            updateAudioVisualizer(audioData) {
                const bars = this.visualizer.querySelectorAll('.bar');
                const bufferLength = audioData.length;
                const barCount = bars.length;
                const samplesPerBar = Math.floor(bufferLength / barCount);
                
                for (let i = 0; i < barCount; i++) {
                    let sum = 0;
                    for (let j = 0; j < samplesPerBar; j++) {
                        sum += Math.abs(audioData[i * samplesPerBar + j]);
                    }
                    const average = sum / samplesPerBar;
                    const height = Math.min(50, average * 500);
                    bars[i].style.height = `${Math.max(2, height)}px`;
                    bars[i].style.background = height > 10 ? '#28a745' : 'rgba(255, 255, 255, 0.3)';
                }
            }
            
            updateVAD(isActive) {
                this.vadLight.classList.toggle('active', isActive);
                this.vadStatus.textContent = isActive ? 'Speaking' : 'Inactive';
            }
            
            addMessage(text, isUser = false, isPartial = false) {
                const messageEl = document.createElement('div');
                messageEl.className = `message ${isUser ? 'user-message' : 'agent-message'}`;
                if (isPartial) messageEl.classList.add('partial-message');
                
                messageEl.textContent = text;
                this.conversationEl.appendChild(messageEl);
                this.conversationEl.scrollTop = this.conversationEl.scrollHeight;
                
                return messageEl;
            }
            
            updateLatency(startTime) {
                const latency = Date.now() - startTime;
                this.latencyInfo.textContent = `Latency: ${latency}ms`;
            }
            
            stopCurrentAudio() {
                // Stop any currently playing audio
                if (this.currentAudioSource) {
                    try {
                        this.currentAudioSource.stop();
                        console.log('üõë Stopped previous audio (barge-in)');
                    } catch (e) {
                        // Audio might have already ended naturally
                    }
                    this.currentAudioSource = null;
                }
            }

            async playAudioChunk(audioBase64) {
                try {
                    // Stop any previous audio before playing new one
                    this.stopCurrentAudio();
                    
                    const audioData = atob(audioBase64);
                    const audioArray = new Uint8Array(audioData.length);
                    for (let i = 0; i < audioData.length; i++) {
                        audioArray[i] = audioData.charCodeAt(i);
                    }
                    
                    // Reuse existing audioContext if available
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    const audioBuffer = await this.audioContext.decodeAudioData(audioArray.buffer);
                    const source = this.audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(this.audioContext.destination);
                    
                    // Track this source for potential interruption
                    this.currentAudioSource = source;
                    
                    // Clear reference when audio ends naturally
                    source.onended = () => {
                        if (this.currentAudioSource === source) {
                            this.currentAudioSource = null;
                        }
                    };
                    
                    source.start();
                    console.log('üîä Playing TTS audio');
                    
                } catch (error) {
                    console.error('Error playing audio:', error);
                }
            }
            
            handleMessage(data) {
                console.log('Received:', data);
                
                switch (data.type) {
                    case 'connection_ready':
                        console.log('Connection ready');
                        break;
                        
                    case 'stt_ready':
                        this.sttActive = true;
                        console.log('STT ready');
                        break;
                        
                    case 'stt_unavailable':
                        alert('Speech-to-text service unavailable. Please check Deepgram API key.');
                        this.stopVoiceChat();
                        break;
                        
                    case 'speech_started':
                        this.updateVAD(true);
                        this.updateStatus('Speaking detected...', 'speaking');
                        this.lastSpeechTime = Date.now();
                        // BARGE-IN: Stop any currently playing TTS audio
                        this.stopCurrentAudio();
                        break;
                        
                    case 'utterance_end':
                        this.updateVAD(false);
                        this.updateStatus('Processing...', 'listening');
                        break;
                        
                    case 'partial_transcript':
                        // Update or create partial message
                        let partialEl = this.conversationEl.querySelector('.partial-message');
                        if (partialEl) {
                            partialEl.textContent = data.text;
                        } else {
                            this.addMessage(data.text, true, true);
                        }
                        break;
                        
                    case 'final_transcript':
                        // Remove partial message and add final
                        const partialMsg = this.conversationEl.querySelector('.partial-message');
                        if (partialMsg) partialMsg.remove();
                        
                        this.addMessage(data.text, true);
                        this.updateLatency(this.lastSpeechTime);
                        break;
                        
                    case 'agent_response':
                        this.addMessage(data.text, false);
                        this.updateStatus('Listening... Speak naturally!', 'listening');
                        break;
                        
                    case 'audio_chunk':
                        this.playAudioChunk(data.audio);
                        break;
                        
                    case 'audio_end':
                        console.log('Audio playback complete');
                        break;

                    case 'audio':
                        // Non-streaming TTS from server
                        this.playAudioChunk(data.audio);
                        break;
                        
                    case 'tts_interrupted':
                        console.log('TTS interrupted by user speech');
                        break;
                        
                    case 'tts_cancelled':
                        console.log('TTS cancelled');
                        break;
                        
                    case 'error':
                        console.error('Server error:', data.message);
                        this.addMessage(`Error: ${data.message}`, false);
                        break;
                        
                    default:
                        console.log('Unknown message type:', data.type);
                }
            }
        }
        
        // Initialize the client when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new RealtimeVoiceClient();
        });
    </script>
</body>
</html>
